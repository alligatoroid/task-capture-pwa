class TaskCaptureApp {
  constructor() {
    this.notes = [];
    this.stream = null;
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.recordingTimer = null;
    this.currentPhoto = null;
    this.markupCanvas = null;
    this.markupCtx = null;
    this.markupTool = 'pen';
    this.markupColor = '#ff0000';
    this.markupHistory = [];
    this.isDrawing = false;
    this.lastX = 0;
    this.lastY = 0;
    this.apiBaseUrl = '/api/notes';
    
    this.init();
  }
  
  init() {
    this.loadNotes();
    this.setupEventListeners();
    this.setupServiceWorker();
  }
  
  async loadNotes() {
    try {
      const response = await fetch(this.apiBaseUrl);
      if (response.ok) {
        this.notes = await response.json();
        this.renderInbox();
      }
    } catch (error) {
      console.error('Failed to load notes:', error);
      this.notes = [];
      this.renderInbox();
    }
  }
  
  renderInbox() {
    const inbox = document.getElementById('inbox');
    if (!inbox) return;
    
    const groupedNotes = this.groupNotesByDate(this.notes);
    
    inbox.innerHTML = Object.entries(groupedNotes)
      .sort(([a], [b]) => new Date(b) - new Date(a))
      .map(([date, notes]) => `
        <div class="date-group">
          <h3 class="date-header">${this.formatDate(date)}</h3>
          <div class="notes-list">
            ${notes.map(note => this.renderNote(note)).join('')}
          </div>
        </div>
      `).join('');
  }
  
  groupNotesByDate(notes) {
    return notes.reduce((groups, note) => {
      const date = new Date(note.created_at).toLocaleDateString();
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(note);
      return groups;
    }, {});
  }
  
  formatDate(dateStr) {
    const date = new Date(dateStr);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) {
      return 'Today';
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'Yesterday';
    }
    return date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      month: 'short', 
      day: 'numeric' 
    });
  }
  
  renderNote(note) {
    let content = '';
    
    if (note.type === 'text') {
      content = `<p class="note-text">${this.escapeHtml(note.content)}</p>`;
    } else if (note.type === 'audio') {
      content = `
        <div class="note-audio">
          <audio controls src="${note.audio_url}"></audio>
          <span class="duration">${this.formatDuration(note.duration)}</span>
        </div>
      `;
    } else if (note.type === 'photo') {
      content = `
        <div class="note-photo">
          <img src="${note.photo_url}" alt="Note photo" loading="lazy">
        </div>
      `;
    } else if (note.type === 'markup') {
      content = `
        <div class="note-markup">
          <img src="${note.photo_url}" alt="Markup photo" loading="lazy">
        </div>
      `;
    }
    
    const time = new Date(note.created_at).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit'
    });
    
    return `
      <div class="note-item" data-id="${note.id}">
        <div class="note-header">
          <span class="note-type">${this.getTypeIcon(note.type)}</span>
          <span class="note-time">${time}</span>
          <button class="btn-delete" data-id="${note.id}" aria-label="Delete note">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 6h18"></path>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
              <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
          </button>
        </div>
        ${content}
      </div>
    `;
  }
  
  getTypeIcon(type) {
    const icons = {
      text: 'ðŸ“',
      audio: 'ðŸŽ¤',
      photo: 'ðŸ“·',
      markup: 'âœï¸'
    };
    return icons[type] || 'ðŸ“Œ';
  }
  
  formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  [{"Enter' && quickText.value.trim()) {\n          this.saveQuickText(quickText.value.trim());\n          quickText.value = '": ""}, {}]
    
    // Close modal buttons
    document.querySelectorAll('[data-close-modal]').forEach(btn => {
      btn.addEventListener('click', () => {
        const modal = btn.closest('.modal');
        if (modal) {
          this.hideModal(modal.id);
        }
      });
    });
    
    // Close modal on backdrop click
    document.querySelectorAll('.modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.hideModal(modal.id);
        }
      });
    });
    
    // Text note save
    const saveTextBtn = document.getElementById('save-text-note');
    if (saveTextBtn) {
      saveTextBtn.addEventListener('click', () => this.saveTextNote());
    }
    
    // Voice recording
    const startRecordBtn = document.getElementById('start-record');
    const stopRecordBtn = document.getElementById('stop-record');
    if (startRecordBtn) {
      startRecordBtn.addEventListener('click', () => this.startRecording());
    }
    if (stopRecordBtn) {
      stopRecordBtn.addEventListener('click', () => this.stopRecording());
    }
    
    // Camera capture
    const captureBtn = document.getElementById('capture-photo');
    if (captureBtn) {
      captureBtn.addEventListener('click', () => this.capturePhoto());
    }
    
    // Markup tools
    this.setupMarkupTools();
    
    // Delete note buttons (event delegation)
    const inbox = document.getElementById('inbox');
    if (inbox) {
      inbox.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.btn-delete');
        if (deleteBtn) {
          const noteId = deleteBtn.dataset.id;
          this.deleteNote(noteId);
        }
      });
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
          this.hideModal(modal.id);
        });
      }
    });
  }
  
  setupMarkupTools() {
    const canvas = document.getElementById('markup-canvas');
    if (canvas) {
      this.markupCanvas = canvas;
      this.markupCtx = canvas.getContext('2d');
      
      // Mouse events
      canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
      canvas.addEventListener('mousemove', (e) => this.draw(e));
      canvas.addEventListener('mouseup', () => this.stopDrawing());
      canvas.addEventListener('mouseout', () => this.stopDrawing());
      
      // Touch events
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.startDrawing(e.touches[0]);
      });
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        this.draw(e.touches[0]);
      });
      canvas.addEventListener('touchend', () => this.stopDrawing());
    }
    
    // Tool selection
    document.querySelectorAll('[data-markup-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        this.markupTool = btn.dataset.markupTool;
        document.querySelectorAll('[data-markup-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });
    
    // Color selection
    document.querySelectorAll('[data-markup-color]').forEach(btn => {
      btn.addEventListener('click', () => {
        this.markupColor = btn.dataset.markupColor;
        document.querySelectorAll('[data-markup-color]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });
    
    // Undo
    const undoBtn = document.getElementById('undo-markup');
    if (undoBtn) {
      undoBtn.addEventListener('click', () => this.undoMarkup());
    }
    
    // Clear
    const clearBtn = document.getElementById('clear-markup');
    if (clearBtn) {
      clearBtn.addEventListener('click', () => this.clearMarkup());
    }
    
    // Save markup
    const saveMarkupBtn = document.getElementById('save-markup');
    if (saveMarkupBtn) {
      saveMarkupBtn.addEventListener('click', () => this.saveMarkup());
    }
  }
  
  startDrawing(e) {
    this.isDrawing = true;
    const rect = this.markupCanvas.getBoundingClientRect();
    this.lastX = e.clientX - rect.left;
    this.lastY = e.clientY - rect.top;
    
    // Save state for undo
    this.markupHistory.push(this.markupCanvas.toDataURL());
  }
  
  draw(e) {
    if (!this.isDrawing) return;
    
    const rect = this.markupCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    this.markupCtx.strokeStyle = this.markupColor;
    this.markupCtx.lineWidth = this.markupTool === 'pen' ? 3 : 10;
    this.markupCtx.lineCap = 'round';
    this.markupCtx.lineJoin = 'round';
    
    this.markupCtx.beginPath();
    this.markupCtx.moveTo(this.lastX, this.lastY);
    this.markupCtx.lineTo(x, y);
    this.markupCtx.stroke();
    
    this.lastX = x;
    this.lastY = y;
  }
  
  stopDrawing() {
    this.isDrawing = false;
  }
  
  undoMarkup() {
    if (this.markupHistory.length > 0) {
      const lastState = this.markupHistory.pop();
      const img = new Image();
      img.onload = () => {
        this.markupCtx.clearRect(0, 0, this.markupCanvas.width, this.markupCanvas.height);
        this.markupCtx.drawImage(img, 0, 0);
      };
      img.src = lastState;
    }
  }
  
  clearMarkup() {
    this.markupHistory.push(this.markupCanvas.toDataURL());
    this.markupCtx.clearRect(0, 0, this.markupCanvas.width, this.markupCanvas.height);
    
    // Redraw the original photo
    if (this.currentPhoto) {
      const img = new Image();
      img.onload = () => {
        this.markupCtx.drawImage(img, 0, 0, this.markupCanvas.width, this.markupCanvas.height);
      };
      img.src = this.currentPhoto;
    }
  }
  
  async saveMarkup() {
    const dataUrl = this.markupCanvas.toDataURL('image/png');
    
    try {
      const response = await fetch(this.apiBaseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'markup',
          photo_data: dataUrl,
        }),
      });
      
      if (response.ok) {
        const note = await response.json();
        this.notes.unshift(note);
        this.renderInbox();
        this.hideModal('markup-modal');
        this.showToast('Photo with markup saved!');
      } else {
        throw new Error('Failed to save markup');
      }
    } catch (error) {
      console.error('Error saving markup:', error);
      this.showToast('Failed to save markup');
    }
  }
  
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(this.stream);
      this.audioChunks = [];
      
      this.mediaRecorder.ondataavailable = (e) => {
        this.audioChunks.push(e.data);
      };
      
      this.mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
        await this.saveAudioNote(audioBlob);
      };
      
      this.mediaRecorder.start();
      
      // Update UI
      document.getElementById('start-record').classList.add('hidden');
      document.getElementById('stop-record').classList.remove('hidden');
      document.getElementById('recording-status').classList.remove('hidden');
      
      // Start timer
      this.recordingStartTime = Date.now();
      this.recordingTimer = setInterval(() => this.updateRecordingTimer(), 100);
      
    } catch (error) {
      console.error('Error starting recording:', error);
      this.showToast('Failed to access microphone');
    }
  }
  
  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
      this.mediaRecorder.stop();
      this.stream.getTracks().forEach(track => track.stop());
    }
    
    // Clear timer
    if (this.recordingTimer) {
      clearInterval(this.recordingTimer);
      this.recordingTimer = null;
    }
    
    // Update UI
    document.getElementById('start-record').classList.remove('hidden');
    document.getElementById('stop-record').classList.add('hidden');
    document.getElementById('recording-status').classList.add('hidden');
    document.getElementById('recording-time').textContent = '0:00';
  }
  
  updateRecordingTimer() {
    const elapsed = (Date.now() - this.recordingStartTime) / 1000;
    const mins = Math.floor(elapsed / 60);
    const secs = Math.floor(elapsed % 60);
    document.getElementById('recording-time').textContent = 
      `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  async saveAudioNote(audioBlob) {
    const formData = new FormData();
    formData.append('type', 'audio');
    formData.append('audio', audioBlob, 'recording.webm');
    formData.append('duration', (Date.now() - this.recordingStartTime) / 1000);
    
    try {
      const response = await fetch(this.apiBaseUrl, {
        method: 'POST',
        body: formData,
      });
      
      if (response.ok) {
        const note = await response.json();
        this.notes.unshift(note);
        this.renderInbox();
        this.showToast('Audio note saved!');
      } else {
        throw new Error('Failed to save audio');
      }
    } catch (error) {
      console.error('Error saving audio:', error);
      this.showToast('Failed to save audio note');
    }
  }
  
  async capturePhoto() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' } 
      });
      
      const video = document.getElementById('camera-preview');
      video.srcObject = this.stream;
      video.play();
      
      document.getElementById('capture-photo').classList.add('hidden');
      document.getElementById('use-photo').classList.remove('hidden');
      document.getElementById('retake-photo').classList.remove('hidden');
      
    } catch (error) {
      console.error('Error accessing camera:', error);
      this.showToast('Failed to access camera');
    }
  }
  
  usePhoto() {
    const video = document.getElementById('camera-preview');
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    
    this.currentPhoto = canvas.toDataURL('image/jpeg', 0.8);
    
    // Stop camera stream
    this.stream.getTracks().forEach(track => track.stop());
    
    // Show markup modal with the photo
    this.setupMarkupCanvas(this.currentPhoto);
    this.showModal('markup-modal');
    this.hideModal('camera-modal');
    
    // Reset camera modal
    document.getElementById('capture-photo').classList.remove('hidden');
    document.getElementById('use-photo').classList.add('hidden');
    document.getElementById('retake-photo').classList.add('hidden');
  }
  
  retakePhoto() {
    this.stream.getTracks().forEach(track => track.stop());
    this.capturePhoto();
    
    document.getElementById('capture-photo').classList.remove('hidden');
    document.getElementById('use-photo').classList.add('hidden');
    document.getElementById('retake-photo').classList.add('hidden');
  }
  
  setupMarkupCanvas(photoDataUrl) {
    const canvas = this.markupCanvas;
    const ctx = this.markupCtx;
    
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
    };
    img.src = photoDataUrl;
    
    this.markupHistory = [];
  }
  
  async saveTextNote() {
    const textarea = document.getElementById('note-content');
    const content = textarea.value.trim();
    
    if (!content) {
      this.showToast('Please enter some text');
      return;
    }
    
    try {
      const response = await fetch(this.apiBaseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'text',
          content: content,
        }),
      });
      
      if (response.ok) {
        const note = await response.json();
        this.notes.unshift(note);
        this.renderInbox();
        textarea.value = '';
        this.hideModal('text-modal');
        this.showToast('Note saved!');
      } else {
        throw new Error('Failed to save note');
      }
    } catch (error) {
      console.error('Error saving note:', error);
      this.showToast('Failed to save note');
    }
  }
  
  async deleteNote(noteId) {
    if (!confirm('Are you sure you want to delete this note?')) {
      return;
    }
    
    try {
      const response = await fetch(`${this.apiBaseUrl}/${noteId}`, {
        method: 'DELETE',
      });
      
      if (response.ok) {
        this.notes = this.notes.filter(n => n.id !== noteId);
        this.renderInbox();
        this.showToast('Note deleted');
      } else {
        throw new Error('Failed to delete note');
      }
    } catch (error) {
      console.error('Error deleting note:', error);
      this.showToast('Failed to delete note');
    }
  }
  
  setupServiceWorker() {
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('ServiceWorker registration successful');
          })
          .catch((error) => {
            console.log('ServiceWorker registration failed:', error);
          });
      });
    }
  }
  
  showModal(id) {
    const modal = document.getElementById(id);
    if (modal) {
      modal.classList.remove('hidden');
      
      // Start camera if opening camera modal
      if (id === 'camera-modal') {
        this.capturePhoto();
      }
    }
  }
  
  hideModal(id) {
    const modal = document.getElementById(id);
    if (modal) {
      modal.classList.add('hidden');
      
      // Stop camera if closing camera modal
      if (id === 'camera-modal' && this.stream) {
        this.stream.getTracks().forEach(track => track.stop());
      }
    }
  }
  
  showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.add('show'), 10);
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }
}

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.app = new TaskCaptureApp();
});
